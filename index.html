<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>lisafeather.github.io by feather</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>web wevelopment, art, climbing</h1>
        <h2>thoughts of a Feather</h2>
        <a href="https://github.com/lisafeather" class="button"><small>Follow me on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h3>
            <a name="mv-rails" class="anchor" href="#mv-rails"><span class="octicon octicon-link"></span></a>
            MV* + Rails
          </h3>
          <p>The MVC design pattern originated with SmallTalk in 1978. It predates so many things it's no wonder that many different takes on it have evolved. Models are usually some form of data store, be it an actual database or JSON. Views are an interface, be it templates used a presentation layer or an API feeding another app. In some cases the View is actually not seen. The Controller serves as the glue between the Model and the View, handling interaction and directing user actions. Some may disagree with this definition. One thing we can all agree on is that it's best to separate your concerns, and it's best to avoid JavaScript spaghetti. This has resulted in a bounty of JavaScript frameworks that approach the MVC design pattern in different ways. In his <a href="http://www.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/">article</a>, Addy Osmani guides us gently through the MV* framework jungle. Much has changed since 2012, when the article was written, but it is a good place to start.</p>
            <img src="http://www.hot-map.com/images/tn/Themenkarte-Paris-MÃ©tro-Liniennetz-5308.jpg" height=300 />
         <p>To satisfy my own curiosity about using JS frameworks within a Rails app, I tried building the same app using Backbone.js, Angular.js, and Ember.js. I'd had the most exposure to Backbone previously, so that one was easiest for me. This in no way suggests that Backbone is the easiest framework to learn. Au contraire, mon fr&egrave;re! Backbone is the granddaddy of them all and has the crotchety minimalism to prove it. It is the least opinionated of the three.</p>

          <p>IMHO it's always better to start with a standalone app using a new framework, then progress to using the framework in a Rails app. My exposure to Backbone began with a weekend workshop through <a href="http://www.girldevelopit.com/chapters/san-francisco">Girl Develop It</a> in which we built a small app to catalog music. This helped me to understand the basic components you get with Backbone, Models, Views and Collections. (You also get Routes, but many Backbone developers opt to use their own routing or Pages.js.)</p>

          <p>Later I went on to teach Backbone at a web development bootcamp. It was interesting to watch students who had a certain level of confidence fall apart when introduced to Backbone. To someone with a strong background in OO programming it will be intuitive. For those new to programming, it is apparently really difficult to understand the why of it. It made a lot more sense to students when we did an in-class coding session showing how Backbone Models and Collections can be created and displayed. Yay objects! But until one has worked with a large legacy codebase full of crazy spaghetti, the why of it will not be really clear.</p>

          <p>As part of my teaching prep I followed the <a href="http://railscasts.com/episodes/323-backbone-on-rails-part-1?view=asciicast">Railscasts tutorial</a> on making a small Rails app using Backbone. All the Railscasts on MV* are in CoffeeScript, which may make it a bit more confusing at first. It only took a few hours to build my little app and understand how all the parts fit together. The gem used is <a href="https://github.com/codebrew/backbone-rails">backbone-rails</a>. There is a little app tutorial on the Github page that's more up to date. In 2013 you had to use the <code>--use-javascript</code> extension when generating your files if you didn't want to end up with CoffeeScript, but I saw no mention of this and the code generated appears to be straight JavaScript. A lot of big Backbone houses that previously used CoffeeScript have been switching back to JavaScript for ease of debugging.</p>

          <p>Ryan Bates points out that 'views in Backbone behave more like controllers in Rails', which really helped me wrap my head around that. The Rails gem comes with a 3 generators that create your Backbone components for you. Your Rails controller just responds with JSON, so it's quite slim. In summary, Backbone is the oldest and most established of the MV* frameworks. It was my introduction to working with OO JavaScript in a formal way. It's pretty lightweight and not very opinionated, making it very flexible. It is really more MVP, since Views handle much of the interactivity that Controllers normally would.</p>

          <p>If Backbone is the grumpy old pappy, the hot new kid in town is definitely Angular. To someone who once used a lot of JavaScript embedded in HTML, Angular feels a bit like kids born in the '90s wearing acid washed jeans. Yipes, your HTML has code in it again! Why bring back the worst things from previous decades?</p>

           <p>After I walked through this <a href="https://docs.angularjs.org/tutorial">tutorial</a>, I found it pretty nifty! You can use a scaffold to generate an Angular app that basically gives you a Node Express type framework with a full test suite built in. You'll get a lot of interactivity without ever touching the Node part of the app.<p>

           <p>Angular has a more classic approach to the MVC pattern. Models have 2-way data bindings, which is a huge feature. Views are DOM elements generated by Models and Controllers. Scopes are classes that observe Models and propigate their changes.
           It gives you filtering with very little code. On the downside, it is extremely opinionated and I found it a little bit more complicated to use with a Rails app.<p>

          <p>Going back to <a href="http://railscasts.com/episodes/405-angularjs?view=comments">Railscasts</a> I was able to build the same app using Angular. This time it did not require a part one and two. Still, I didn't feel like I could take this information and build an app. So I did another tutorial and came up with <a href="https://github.com/lisafeather/stork_watch">Stork Watch</a>. Then I built an app that gets results from the Twitter API but in the end the app worked better with simple JQuery calls.<p>

          <p>So my take on Angular is that it's probably great if you're building a Node app. My jury is still out on Rails + Angular, even though I know a few developers have taken this direction and are happy with it. I'm really curious to know how it compares in terms of speed. My spider sense tells me it can be much slower since you have so much more framework involved. Rails is already pretty framework heavy, so a Node Express app seems like a better fit anyway.</p>

          <p>Lastly I tried Ember. The first step was to build the ever-popular <a href="http://emberjs.com/guides/getting-started/">Todo App</a> on their tutorial page. A first step recommended was to add the <a href="https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi ">Ember Inspector </a>to your Chrome browser. I did this and got an extra tab in my Chrome inspector called "Ember". When clicked on it informed me that this was not an Ember app, even after I had included the Ember.js library and used Ember's create() method to create my Todo object. Alrighty then! There is nice debug information in the console, though. It tells you right off which js libraries and what versions you have, which is quite useful.</p>

          <p>Overall I found Ember really easy and intuitive as a standalone app. You have a lot of structure but also flexibility. Like Backbone, the entire ember.js library is one file. Ember actually feels a bit like the more structured offspring of Backbone. There are some similarities, but Ember has more separation between all of the MVC layers. Ember apps are organized around Routes, which makes it much more opinionated than Backbone. It gives you this without giving you a ton of other stuff you may or may not use, such as  libraries for animation, filtering and such. All of this may be very cool or very useless, depending on what you are building.</p>

          <p>Ember is probably the most compatible JS framework with Rails apps. Going back to the Railscasts on it, I tried and failed to build the same app. The tutorial was a bit too dated for my setup, so I went looking for other projects to test out my new Ember knowledge. There are many Rails developers choosing Ember, so this is not hard to find. I would actually recommend skipping the Railscasts and using a more recent code sample, as Ember has evolved a lot in the past 2 years. Using Ember with a Rails app feels very intuitive. They are both opinionated in similar ways, so if you have an intuitive feel for the Rails way, Ember will be the most natural extension of that.</p>

          <p>In conclusion, I think the best framework to use depends on your goals. If you want a bit of structure but not too many opinions, use Backbone. If you are building a Rails app and maintainability is really important, you might like the convention over configuration aspect to carry through to your JS framework. So pick Ember. If you are building a Node app and you want a lot of rich client-side features, Angular may be a good choice. </p>

          <p>Of course there are many other choices out there that I have not even covered here! If scaling is a big issue, you may instead opt for React. Apparently React doesn't care which JS framework you use, as long as it isn't Angular. The React author also feels that templates aren't really separating your concerns, so they are looking at frameworks like Om that aren't really frameworks at all, but rather a state of mind type thing. In the end the important thing is to use something to separate your concerns and create objects, so you can test your code and other people can read it.</p>

         <a href="./index.html">Back to top</a>
         <h3>
            <a name="factory-girl" class="anchor" href="#factory-girl"><span class="octicon octicon-link"></span></a>
            Testing Rails apps with Factory Girl
          </h3>
          <p>First of all, what a cool retro-futuristic name! Who knows if it's a reference to the film about Andy Warhol's muse, or the Rolling Stones song. Maybe neither. More likely it's a nod towards the <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">design pattern</a>.</p>
            <img src="http://wunderbuzz.co.uk/wp-content/uploads/factorygirl_.jpg" height=300 />

            <p>It's also pretty nifty as a testing tool. Why, you ask? First off, as the name implies, it gives you a factory for test doubles of your objects. The term "test double" comes from the film industry, incidentally. It encapsulates both mocks, which test the behavior of objects, and subs, which test state. For a very well written explanation of this, read Martin Fowler's <a href="http://martinfowler.com/articles/mocksArentStubs.html">article</a>. According to Fowler, TDD testers will either choose to test using the original object, or they will use mocks. Much of this seems to depend on what level of complexity test objects have and how often the same objects get reused. </p>

            <p>Suppose that your app focuses on one particular object, the Cookie, with two attributes of flavor and crunch level. You might drive out your cookie jar functionality with an integration test:</p>

            <pre><code>
            feature 'monitor cookie supply' do
              scenario 'last cookie is eaten' do
                Cookie.create(flavor: 'chocolate bomb', crunch_level: 'ear-rattling')
                user_eats_cookie('messy')
                user_licks_lips
                expect(cookie.jar.length).to eq 0
              end
            end
            </pre></code>

            <p>Each time this test is run a new Cookie object gets created, requiring a call to the database. If you only have only a few tests that deal with cookies this won't be an issue. But suppose you are working for a supplier to the Cookie Monster, and your Rails app has to keep track of many cookies? You might have loads of tests with the Cookie object. In that case you might use a test double to expedite your tests. A good way to do this is the <a href="https://github.com/thoughtbot/factory_girl_rails">factory_girl_rails</a> gem. This gem requires a few minimal configurations before you are ready to rock. The spec_helper.rb file needs to know about it:</p>

            <pre><code>
            config.include FactoryGirl::Syntax::Methods
            </pre></code>

            <p>Now you can refactor your tests to refer to the cookie factory rather than create a new Cookie for each scenario.</p>

           <pre><code>
            feature 'monitor cookie supply' do
              scenario 'last cookie is eaten' do
                create(:cookie, flavor: 'chocolate bomb', crunch_level: 'ear-rattling')
                user_eats_cookie('messy')
                user_licks_lips
                expect(cookie.jar.length).to eq 0
              end
            end
            </pre></code>

            <p>Now if you run your test, Rspec will complain that the factory "cookie" does not exist. So you also need to add a 'factories.rb' file to your spec/ directory to create the cookie factory. <p>

            <pre><code>
            FactoryGirl.define do
              factory :cookie do
                flavor: 'chocolate chip walnut'
                crunch_level: 'medium'
              end
            end
            </pre></code>

            <p>Now every time you want to mock out a Cookie, all you have to do is refer to the cookie factory. Thanks <a href="https://github.com/thoughtbot/factory_girl">Factory Girl</a>!</p>
 <a href="./index.html">Back to top</a>

            <h3>
            <a name="TDD" class="anchor" href="#TDD"><span class="octicon octicon-link"></span></a>
             Outside-in TDD - making life simple
          </h3>
          <p>First off, I'd just like to point out that Capybaras, the animals, are incredibly cute. Also, why is it that animals wearing glasses or goggles are automatically at least 65% more adorable?! This is a big question that Science needs to address ASAP. </p>

          <p>Next I'd like talk about what I've recently learned with respect to Outside-in TDD using tools like <a href="https://rubygems.org/gems/capybara">Capybara</a>, the Ruby gem.</p>
          <img src="images/capybara.jpg" height=300 />

          <p>Although I am not new to web technologies, TDD is a relatively new concept for me. Who had time to test while running from a raging t-rex? Traditionally, code was written by developers and tested by testers. Many developers test their own code now but it is often passed through a QA team before it moves out of staging into production.</p>

          <p>When I first moved from static HTML pages to writing Perl CGI apps, we tested manually. For even the tiniest change you'd spend hours repeatedly clicking through each fixture like a brain-dead monkey, inevitably forgetting something important your first user would surely uncover.</p>

          <p>Luckily, times have changed! Coming to TDD late in the game has presented its own challenges, but has advantages too. I see why, but have struggled with how. Even after beginning to understand the syntax of Rspec, I still wondered where to start. The wildly different views in this arena didn't help, either. The Wikipedia entry on  <a href="http://en.wikipedia.org/wiki/Integration_testing">integration tests</a> says it happens once all the unit testing is complete. Proponents of Outside-in testing give the opposite advice. <a href="http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html">DHH</a> thinks we should focus on regression testing and TDD is dead because of it's propensity to create over-architected solutions. His objection seems mostly to have been met with raised eyebrows and a collective shrug from the Rails community. </p>

          <p>My first real experience of writing Rspec tests on the job involved writing integration tests then controller tests to add new functionality. I was also asked to fill in any missing controller tests so our coverage would be more complete. At the time I was not confident enough to point out that this seemed redundant in some cases, as integration tests had covered controller actions nicely. We were working in a continuous integration environment, so once tests went green new changes got deployed. Things that had not been tested properly would go into production, sometimes causing errors our users would catch. Yikes! Having a monkey-bot click through your site for you is great, but a simple visual click-through before changes go live isn't maybe a terrible idea either.</p>

          <p>By the time I started to learn about Outside-In TDD, I felt pretty comfortable writing controller tests after the fact. Yes, I know, this is not TDD! In fact, many of those who espouse the concept of Outside-In TDD will tell you that writing controller tests often ends up being redundant, as you have already tested your actions through the integration tests. Your unit tests focus mainly on your models. </p>

          <p>The idea is to begin with how you want your app to behave (the "B" in BDD), write integration tests, then drill down into unit tests. Tests focus on results, not implementation. This answers the question of "where to start?" Think first about how your app should behave, write failing tests that specify this behavior, make them green, then refactor. You limit yourself to the most simple failing test, then only write enough code to make it pass in the most inane way possible. What?! My brain cries out to overthink this. It's an exercise in being completely pedantic. It's as if you were a robot who only knows a few basic rules and executes them repeatedly. Don't get me wrong. I have much love for robots, but do I want to become one?!</p>

          <p>The simplicity of this approach is really starting to grow on me, however. It frees up so much space in your head when you are forced to focus on one thing at a time. Rather than turning you into <a href="https://www.youtube.com/watch?v=XtTL0A5nhfk&feature=kp">Bender</a>, it keeps you staring directly at the functionality you want. By not overthinking implementation details in the beginning, you can focus on how you want your code to act. No one will even require you to do the robot dance when you are through! </p>

          <p>Capybara, the gem, is like a tiny monkey who runs through all the boring mechanics of testing your views so you never even have to open a web browser during the development process. If you do things the way you ought (envision giant pointing finger here) your controller will only use restful actions, the results of which will have been tested through your views.</p>

          <pre><code>
            feature "communicate with humans" do
              scenario "indicate a response" do
                visit robot_path
                fill_in "Question", with: "Answer"
                assert_response "bleep!"
              end
            end
          </code></pre>


          <p>Here are some further resources:
            <ul>
              <li><a href="http://guides.rubyonrails.org/testing.html">Ruby Guide to testing</a>, a great place to start but not end your journey
              <li> <a href="http://www.slideshare.net/danielkolman1/tdd-outsidein">A great slide presentation</a>, as a bonus it's kinda funny! </li>
              <li> <a href="https://learn.thoughtbot.com/screencasts/24-getting-the-tdd-ball-rolling">Getting the TDD ball Rolling</a> by <h href="https://learn.thoughtbot.com/">Thoughtbot</a> to better understand why you might want to start with integration tests (not conventional)</li>
            <li> <a href="http://www.amazon.com/The-RSpec-Book-Behaviour-Development/dp/1934356379">The Rspec book</a>, even though Rails comes with a built-in testing framework pretty much everyone uses Rspec (to set up your app create it with  --skip-test-unit)</li>
          </ul>
          Please let me know if you have other great resources to recommend, as I am still learning!</p>
          <a href="./index.html">Back to top</a>


         <h3>
            <a name="vim" class="anchor" href="#vim"><span class="octicon octicon-link"></span></a>
              VIM + Climbing
          </h3>
          <p>Early in my dabbling with UNIX I learned to use the VI editor. This has been very handy over time. When I was living in Thailand rock climbing and dive guiding full time for 6 months, it was a great way to edit and update remote files. I could take a boat to the nearest town to visit a janky little internet cafe and log in to my servers overseas using a DOS window. This way I could keep a travel log to stay closer with with friends and family back home. </p>
          <img src="images/thailand2.jpg" height=300 />

          <p>Many years later I am trying to return to my VI roots with VIM. It reminds me a bit of when I first learned to lead climb. Until I met climbing, I was terrible at every sport. No one wanted me on their team. Climbing is more a brain game, where even the weak can technique through difficult moves. In leading, everything is harder and scarier, but the payoff is worth it. The thing I feared most was falling while clipping the rope. So I practiced this off the wall until it was muscle memory. Now I can clip quickly, even under duress, freeing up my focus for solving the crux of the climb.</p>

          <p>The same must be said of learning to use your favorite code editor. You need to be able to use it without thinking, so you are not fumbling for keys and you can focus on more important tasks. Using keystrokes to navigate and edit files makes it easier to have an uninterrupted flow of thought. </p>

          <p>Learning to use VIM is not easy at first, even if you have a history with VI, its predecessor. There are some good resources out there. Thoughtbot has a series of videos that are specific to file navigation within Rails apps, as well as several handy shortcuts. 
          Here are some others I found useful:
          <ul>
            <li>Customization w/<a href="https://github.com/carlhuda/janus">Janus</a> allows you to set up colors and to open files using gvim from a command line</li>
            <li>Practice commands <a href="http://www.openvim.com/">with prompts</a></li>
            <li>Develop muscle memory <a href="http://vim-adventures.com/">while having fun </a>(sort of)</li>
          </ul>
        </p>

        <p>However difficult it may be to learn VIM, it is still easier than this <a href="https://www.youtube.com/watch?v=6VLj4KRrMPM">training routine</a>!</p>
        <a href="./index.html">Back to top</a>

          <h3>
            <a name="mentoring" class="anchor" href="#mentoring"><span class="octicon octicon-link"></span></a>
              Mentoring
          </h3>

          <p>Many amazing mentors have crossed my path and changed my life for the better. They have guided me toward a successful art career, better nourishment and training habits, as well as 'learning the ropes' of climbing. Professors can be great, but without the TA I never would have made it through my first programming class in college. Even the crazy, foul-mouthed Scottish former hacker who taught me to navigate UNIX changed my life for the better.</p>

          <p>Mentorship, I believe, is the best way to learn something well. Recently I decided to level up my technical skill set, so I signed up for a month of mentoring with <a href="http://learn.thoughtbot.com">Thoughtbot</a>. While I've never formally paid for mentoring, so far this seems to have been a wise decision. Although I have yet to get any real personalized feedback from the mentoring team, it has focused me on a set of particular goals.</p>

          <p>These are:
          <ol>
            <li>better understanding and mastery of Rails</li>
            <li>more confidence that I'm writing the right tests when using TDD</li>
            <li>make the transition from writing code that just works to writing code that is more well designed
            <li>return to my VI roots and start using VIM</li>
            <li>transfer some of my visual skills to pixels by learning web design fundamentals</li>
          </ol>
          Signing up for mentoring coincided with a major overhaul of my <a href="http://www.lisafeather.com">artist web site</a>, so I began with the "Design for Developers" course. This gave me some ideas, although I need to do more sketches and experimentation with layout and have not gotten any feedback from Thoughtbot's mentoring team here. It's long been my belief that beautiful things are not only easier to use but also generally make life better. There is a joy in things that are made well, so this will continue to haunt me until I get it right. </p>

          <p>The site currently has over 250 works of art on it, all images of different sizes. Getting all of that into nicely formatted responsive grids with appropriate white space is a challenge. So, work in progress! My goal was a visually inviting site that feels like a coffee table book and is fun to navigate, even on mobile devices.<a href="mailto:lisafeather@gmail.com"> Feedback</a> welcome!</p>

          <p>I've also just completed the "Intermediate Rails" series. This course assumes you know your way around a Rails app but that you might be guilty of making large, unweildy controllers that have all kinds of crazy methods that go beyond the scope of the 7 restful actions. You might not know how to break code down so your app is more modular. Strong parameters are also used, even though he doesn't use a Rails 4 app. We refactor a lot, breaking the test app down into modular parts so they are more easily extended. </p>

          <p>This series also sets you up nicely for the course on TDD, as he urges you to think about what you want new functionality to do before you think about how to implement it. You write code that causes error messages then fix it, much like the red, green, refactor cycle espoused by the TDD philosophy.</p>

          <p>Overall I am happy with the courses and feel I've learned a lot in a short while. Further learning resources are good, too. One I enjoyed was <a href="http://vimeo.com/12350535">this video</a> of a lecture on SOLID principles by Sandi Metz. She refactors code to use the more relevant parts of SOLID (for Ruby it's only SOD) so your code is easier to extend and test. She discusses <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>, which is a term you also hear bandied about in the Angular world. Regardless of all the debate over TDD, I hope we can still all agree that modular, testable code is better code!</p>

          <p>Another thing we learn about are concerns and using Ruby objects as models by creating classes in your models directory that don't necessarily inherit from ActiveRecord. This is a seriously cool way to break your functionality down into classes that just do one thing. Classes like that are, of course, easier to test and therefore easier to change. Wheeeee! Coding is fun again!</p>
          <a href="./index.html">Back to top</a>

        </section>

        <aside id="sidebar">
        <div class="entry-menu" style="padding-bottom: 50px">

          <p>A series of thoughts and ramblings by a web developer and artist with a passion for learning, awful jokes, and rock climbing.</p>

          <h4>May 21, 2014, <a href="#mentoring">Mentoring</a></h4>
          <h4>May 22, 2014, <a href="#vim">VIM + Climbing</a></h4>
          <h4>June 1, 2014, <a href="#TDD">TDD, where to begin?!</a></h4>
          <h4>June 2, 2014, <a href="#factory-girl">Factory Girl</a></h4>
          <h4>July 16, 2014, <a href="#mv-rails">
          MV* + Rails</a></h4>
       </div>
       <div class="apps">
         <h4>Here are some fun little apps that don't even pretend to solve real world problems!</h4>
          <ul>
            <li>Suppose you have yes/no/maybe type questions and want some cryptic <a href="http://magic-8-ball.herokuapp.com">answers</a>?</li>
            <li>Suppose you want to write an online dating <a href="http://profile-madlibber.herokuapp.com/">profile</a> via mad libs?</li>
            <li>What if you have friends all over the world that you want to play <a href="http://tele-pictionary.herokuapp.com/">Telephone Pictionary</a> with?</li>
            <li>Similarly, what if you want to play <a href="http://exquisitercorpse.herokuapp.com">crazy drawing games</a> with your friends living far away?</li>
          </ul>
      </div>

        </aside>
      </div>
    </div>


  </body>
</html>
